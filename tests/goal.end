Goal (A => B) => ((B => C) => (A => C)) ~ New goal: [=>(A => B) => (B => C) => A => C]

Assume ~ New goal: [=>(B => C) => A => C]

Assume ~ New goal: [=>A => C]

Assume ~ New goal: [=>C]

By (B => C) ~ New goal: [=>B]

By (A => B) ~ New goal: [=>A]

Done ~ Goal completed: (A => B) => (B => C) => A => C

Goal (A => B) => ((B => C) => (A => C)) ~ New goal: [=>(A => B) => (B => C) => A => C]

Assume ~ New goal: [=>(B => C) => A => C]

Assume ~ New goal: [=>A => C]

Assume ~ New goal: [=>C]

By (X => C) ~ error // X => C is not a known rewriting. Use 'force' to use it anyway.

By (X => C), force ~ New goal: [=>X]

By (B => X), force ~ New goal: [=>B]

By (A => B) ~ New goal: [=>A]

Done ~ Goal completed: (A => B) => (B => C) => A => ((B | [=>B => X] | X => X) | [=>X => C] | C => C)

Done ~ error // Goal not completed: [=>B => X]

Goal (A => B => Z) => Z

Assume ~ New goal: [=>Z]

By A => B => Z ~ New goal: [=>B]

// Testing multi-premises rewritings

Define def_and, #A => #B => and(#A, #B)

Goal def_and => X => Y => and(X, Y) ~ New goal: [=>def_and => X => Y => (X ∧ Y)]

Assume
Assume
Assume

Done ~ error // Goal not completed: [=>X ∧ Y]
By def_and ~ New goal: [=>Y]
Done ~ Goal completed: def_and => X => Y => (Y | [=>X] | X => Y => (X ∧ Y))
Done ~ Goal completed: def_and => X => Y => (X ∧ Y)

Goal A
By X => Y => Z => A ~ error // Rules with more than 2 premises are not yet supported. Found 3 premises.

Goal A => B
By X => Y => A => B ~ error // X => Y => A => B is not a known rewriting. Use 'force' to use it anyway.


Goal True => A
Assume
Done ~ error // Goal not completed: [=>A]
Axiom A
Done ~ Goal completed: True => A

Axiom ->, pi
Axiom ->, zero
Axiom ->, dot
Define inc, #k -> S(#k)
Axiom ->, inc
Define def_times, #a -> #b -> #a * #b
Axiom ->, def_times
Goal dot -> 2 * pi
Assume
By def_times ~ New goal: [->pi]
Done ~ Goal completed: dot -> (pi | [->2] | 2 -> pi -> 2 * pi)
Start zero
Use inc ~ Applied rule, new term: 1
Use inc ~ Applied rule, new term: 2
Done ~ Goal completed: dot -> 2 * pi
