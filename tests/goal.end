Goal (A => B) => ((B => C) => (A => C)) ~ New goal: [((A => B) => ((B => C) => (A => C)))]

Intro ~ New goal: [=>((B => C) => (A => C))]

Intro ~ New goal: [=>(A => C)]

Intro ~ New goal: [=>C]

By (B => C) ~ New goal: [=>B]

By (A => B) ~ New goal: [=>A]

Done ~ Goal completed: ((A => B) => ((B => C) => (A => C)))

Goal (A => B) => ((B => C) => (A => C)) ~ New goal: [((A => B) => ((B => C) => (A => C)))]

Intro ~ New goal: [=>((B => C) => (A => C))]

Intro ~ New goal: [=>(A => C)]

Intro ~ New goal: [=>C]

By (X => C) ~ error # (X => C) is not a known rewriting. Use 'force' to use it anyway.

By (X => C), force ~ New goal: [=>X]

By (B => X), force ~ New goal: [=>B]

By (A => B) ~ New goal: [=>A]

Done ~ Goal completed: ((A => B) => ((B => C) => (A => ((B | [=>(B => X)]) | [=>(X => C)]))))

Done ~ error # Goal not completed: [=>(B => X)]

Goal (A => B => Z) => Z

Intro ~ New goal: [=>Z]

By A => B => Z ~ New goal: [=>B]

# Testing multi-premises rewritings

Define def_and, [A] => [B] => and([A], [B])

Goal def_and => X => Y => and(X, Y) ~ New goal: [(([A] => ([B] => and([A], [B]))) => (X => (Y => and(X, Y))))]

Intro
Intro
Intro

Done ~ error # Goal not completed: [=>and(X, Y)]
By def_and ~ New goal: [=>Y]
Done ~ Goal completed: (def_and => (X => (Y => and([=>X], Y))))
Done ~ Goal completed: (def_and => (X => (Y => and(X, Y))))