open Objects

type substitution = (string * obj) list [@@deriving sexp, compare]

(** Applies a substitution map (typically generated by {!unify}) to a term*)
let rec apply_map map = function
  | H (_id, name) as h -> (
      match List.assoc_opt name map with Some obj -> obj | None -> h)
  | T (id, f, children) -> T (id, f, List.map (apply_map map) children)
  | R (id, v, pattern, result) ->
      R (id, v, apply_map map pattern, apply_map map result)
  | C (id, obj, rule) -> C (id, apply_map map obj, apply_map map rule)

(** Applies a unification algorithm to two patterns. On success, returns a substitution map (association list) with a term for every hole.*)
let unify a b =
  let rec aux map remaining =
    match remaining with
    | [] -> map
    | (a, b) :: remaining -> (
        match (a, b) with
        | t, t' when t = t' -> aux map remaining
        | H (_, name), t when not (List.mem name (get_holes t)) ->
            let new_sub = (name, t) in
            aux (new_sub :: map)
              (List.map
                 (fun (x, y) ->
                   ((apply_map [ new_sub ]) x, (apply_map [ new_sub ]) y))
                 remaining)
        | t, H (_, name) when not (List.mem name (get_holes t)) ->
            let new_sub = (name, t) in
            aux (new_sub :: map)
              (List.map
                 (fun (x, y) ->
                   ((apply_map [ new_sub ]) x, (apply_map [ new_sub ]) y))
                 remaining)
        | T (_, f, children), T (_, f', children') when f = f' ->
            aux map (List.combine children children' @ remaining)
        | R (_, v, left, right), R (_, v', left', right') when v = v' ->
            aux map ((left, left') :: (right, right') :: remaining)
        | C (_, left, right), C (_, left', right') ->
            aux map ((left, left') :: (right, right') :: remaining)
        | _ ->
            failwith
              ("Can not unify" ^ Display.display a ^ " and " ^ Display.display b)
        )
  in
  aux [] [ (a, b) ]
